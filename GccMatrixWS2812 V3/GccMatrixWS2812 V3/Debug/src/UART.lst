   1               		.file	"UART.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.UART_Init,"ax",@progbits
  11               	.global	UART_Init
  13               	UART_Init:
  14               	.LFB6:
  15               		.file 1 "../src/UART.c"
   1:../src/UART.c **** /*
   2:../src/UART.c ****  * UART.c
   3:../src/UART.c ****  *
   4:../src/UART.c ****  * Created: 11/2/2022 1:03:09 PM
   5:../src/UART.c ****  *  Author: jacoby
   6:../src/UART.c ****  */ 
   7:../src/UART.c **** 
   8:../src/UART.c **** 
   9:../src/UART.c **** 
  10:../src/UART.c **** #define F_CPU 16000000UL // Defining the CPU Frequency
  11:../src/UART.c **** 
  12:../src/UART.c **** #include <avr/io.h>      // Contains all the I/O Register Macros
  13:../src/UART.c **** #include <util/delay.h>  // Generates a Blocking Delay
  14:../src/UART.c **** #include <avr/interrupt.h>
  15:../src/UART.c **** #include <stdint.h>
  16:../src/UART.c **** #include "UART.h"
  17:../src/UART.c **** #include "cqueue.h"
  18:../src/UART.c **** 
  19:../src/UART.c **** 
  20:../src/UART.c **** #define USART_BAUDRATE 9600 // Desired Baud Rate
  21:../src/UART.c **** #define BAUD_PRESCALER (((F_CPU / (USART_BAUDRATE * 16UL))) - 1)
  22:../src/UART.c **** 
  23:../src/UART.c **** #define ASYNCHRONOUS (0<<UMSEL00) // USART Mode Selection
  24:../src/UART.c **** 
  25:../src/UART.c **** #define DISABLED    (0<<UPM00)
  26:../src/UART.c **** #define EVEN_PARITY (2<<UPM00)
  27:../src/UART.c **** #define ODD_PARITY  (3<<UPM00)
  28:../src/UART.c **** #define PARITY_MODE  DISABLED // USART Parity Bit Selection
  29:../src/UART.c **** 
  30:../src/UART.c **** #define ONE_BIT (0<<USBS0)
  31:../src/UART.c **** #define TWO_BIT (1<<USBS0)
  32:../src/UART.c **** #define STOP_BIT ONE_BIT      // USART Stop Bit Selection
  33:../src/UART.c **** 
  34:../src/UART.c **** #define FIVE_BIT  (0<<UCSZ00)
  35:../src/UART.c **** #define SIX_BIT   (1<<UCSZ00)
  36:../src/UART.c **** #define SEVEN_BIT (2<<UCSZ00)
  37:../src/UART.c **** #define EIGHT_BIT (3<<UCSZ00)
  38:../src/UART.c **** #define DATA_BIT   EIGHT_BIT  // USART Data Bit Selection
  39:../src/UART.c **** #define RX_COMPLETE_INTERRUPT         (1<<RXCIE0)
  40:../src/UART.c **** #define DATA_REGISTER_EMPTY_INTERRUPT (1<<UDRIE0)
  41:../src/UART.c **** 
  42:../src/UART.c **** 
  43:../src/UART.c **** 
  44:../src/UART.c **** 
  45:../src/UART.c **** 
  46:../src/UART.c **** 
  47:../src/UART.c **** volatile uint8_t USART_TransmitBuffer; // Global Buffer
  48:../src/UART.c **** volatile uint8_t USART_ReceiveBuffer; // Global Buffer
  49:../src/UART.c **** 
  50:../src/UART.c **** void UART_TransmitInterrupt(uint8_t Buffer);
  51:../src/UART.c **** void UART_TransmitPolling(uint8_t DataByte);
  52:../src/UART.c **** uint8_t UART_ReceivePolling(void);
  53:../src/UART.c **** 
  54:../src/UART.c **** void UART_Init()
  55:../src/UART.c **** {
  16               		.loc 1 55 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  56:../src/UART.c **** 	// Set Baud Rate
  57:../src/UART.c **** 	UBRR0H = BAUD_PRESCALER >> 8;
  22               		.loc 1 57 0
  23 0000 1092 C500 		sts 197,__zero_reg__
  58:../src/UART.c **** 	UBRR0L = BAUD_PRESCALER;
  24               		.loc 1 58 0
  25 0004 87E6      		ldi r24,lo8(103)
  26 0006 8093 C400 		sts 196,r24
  59:../src/UART.c **** 	
  60:../src/UART.c **** 	// Set Frame Format
  61:../src/UART.c **** 	UCSR0C = ASYNCHRONOUS | PARITY_MODE | STOP_BIT | DATA_BIT;
  27               		.loc 1 61 0
  28 000a 86E0      		ldi r24,lo8(6)
  29 000c 8093 C200 		sts 194,r24
  62:../src/UART.c **** 	
  63:../src/UART.c **** 	// Enable Receiver and Transmitter
  64:../src/UART.c **** 	UCSR0B = (1<<RXEN0) | (1<<TXEN0);
  30               		.loc 1 64 0
  31 0010 E1EC      		ldi r30,lo8(-63)
  32 0012 F0E0      		ldi r31,0
  33 0014 88E1      		ldi r24,lo8(24)
  34 0016 8083      		st Z,r24
  65:../src/UART.c **** 	
  66:../src/UART.c **** 	// RX Interrupts
  67:../src/UART.c **** 	UCSR0B |= RX_COMPLETE_INTERRUPT; //Enable RX interrupts
  35               		.loc 1 67 0
  36 0018 8081      		ld r24,Z
  37 001a 8068      		ori r24,lo8(-128)
  38 001c 8083      		st Z,r24
  68:../src/UART.c **** 	
  69:../src/UART.c **** 	QueueInit();	// initialize RX queue
  39               		.loc 1 69 0
  40 001e 0E94 0000 		call QueueInit
  41               	.LVL0:
  42               	.LBB4:
  43               	.LBB5:
  44               		.file 2 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\in
   1:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    All rights reserved.
   5:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   6:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   9:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  12:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      distribution.
  16:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  17:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  21:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  33:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* $Id$ */
  34:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  35:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  38:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  endif
  42:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  44:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <math.h>
  47:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  48:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \file */
  49:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \code
  51:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \endcode
  55:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  56:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     used.
  60:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  61:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  70:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  79:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  83:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** */
  84:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  85:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  89:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  90:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \def F_CPU
  95:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  97:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 103:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     integer value.
 107:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 108:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 110:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 111:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 114:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 115:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  include <math.h>
 119:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 120:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 121:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 122:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 124:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 126:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 129:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 131:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 137:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 142:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 147:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 151:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 152:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 153:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 154:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 164:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 165:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 166:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 168:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 176:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 179:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 182:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 183:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 184:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 186:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 187:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  45               		.loc 2 187 0
  46 0022 8FE9      		ldi r24,lo8(3999)
  47 0024 9FE0      		ldi r25,hi8(3999)
  48 0026 0197      	1:	sbiw r24,1
  49 0028 01F4      		brne 1b
  50 002a 00C0      		rjmp .
  51 002c 0000      		nop
  52               	.LVL1:
  53 002e 0895      		ret
  54               	.LBE5:
  55               	.LBE4:
  56               		.cfi_endproc
  57               	.LFE6:
  59               		.section	.text.UART_rx_status,"ax",@progbits
  60               	.global	UART_rx_status
  62               	UART_rx_status:
  63               	.LFB9:
  70:../src/UART.c **** 	
  71:../src/UART.c **** 	_delay_ms(1);  //Allow dividers to settle 
  72:../src/UART.c **** }
  73:../src/UART.c **** 
  74:../src/UART.c **** // Test Bench
  75:../src/UART.c **** int uart_test(void)
  76:../src/UART.c **** {
  77:../src/UART.c **** 
  78:../src/UART.c **** 	char rxdata;
  79:../src/UART.c **** 	while (1)
  80:../src/UART.c **** 	{
  81:../src/UART.c **** 
  82:../src/UART.c **** //			TX IRQ Test
  83:../src/UART.c **** /*
  84:../src/UART.c **** 			sei();					// Enable global Interrupts
  85:../src/UART.c **** 			while(1)
  86:../src/UART.c **** 			{
  87:../src/UART.c **** 					USART_TransmitInterrupt('A');
  88:../src/UART.c **** 					_delay_ms(500);
  89:../src/UART.c **** 			}
  90:../src/UART.c **** */
  91:../src/UART.c **** 
  92:../src/UART.c **** 
  93:../src/UART.c **** //			RX IRQ Test
  94:../src/UART.c **** 
  95:../src/UART.c **** 
  96:../src/UART.c **** 
  97:../src/UART.c **** 			while(1)
  98:../src/UART.c **** 			{
  99:../src/UART.c **** 				if(UART_rx_status())
 100:../src/UART.c **** 				{
 101:../src/UART.c **** 					rxdata=UART_get_data();
 102:../src/UART.c **** 					UART_send_data(rxdata+1);
 103:../src/UART.c **** 					
 104:../src/UART.c **** 				}
 105:../src/UART.c **** 			
 106:../src/UART.c **** 			}
 107:../src/UART.c **** 	}
 108:../src/UART.c **** 	
 109:../src/UART.c **** 	return 0;
 110:../src/UART.c **** }
 111:../src/UART.c **** 		
 112:../src/UART.c **** 
 113:../src/UART.c **** 
 114:../src/UART.c **** 
 115:../src/UART.c **** 
 116:../src/UART.c **** // ==========================SERVICES=========================================//
 117:../src/UART.c **** //***************************************
 118:../src/UART.c **** // UART_putstring(uint8_t*)
 119:../src/UART.c **** // Sends a null terminated string
 120:../src/UART.c **** //***************************************
 121:../src/UART.c **** void UART_putstring(uint8_t* StringPtr){
 122:../src/UART.c **** 	while(*StringPtr != 0x00){
 123:../src/UART.c **** 		UART_send_data(*StringPtr);
 124:../src/UART.c **** 	StringPtr++;}
 125:../src/UART.c **** }
 126:../src/UART.c **** 
 127:../src/UART.c **** 
 128:../src/UART.c **** //***************************************
 129:../src/UART.c **** // UART_rx_status(void)
 130:../src/UART.c **** // returns <> 0 if any data was received 
 131:../src/UART.c **** //***************************************
 132:../src/UART.c **** uint8_t UART_rx_status(void)
 133:../src/UART.c **** {
  64               		.loc 1 133 0
  65               		.cfi_startproc
  66               	/* prologue: function */
  67               	/* frame size = 0 */
  68               	/* stack size = 0 */
  69               	.L__stack_usage = 0
 134:../src/UART.c **** 	return (QueueStatus());
  70               		.loc 1 134 0
  71 0000 0E94 0000 		call QueueStatus
  72               	.LVL2:
 135:../src/UART.c **** }
  73               		.loc 1 135 0
  74 0004 0895      		ret
  75               		.cfi_endproc
  76               	.LFE9:
  78               		.section	.text.UART_get_data,"ax",@progbits
  79               	.global	UART_get_data
  81               	UART_get_data:
  82               	.LFB10:
 136:../src/UART.c **** //***************************************
 137:../src/UART.c **** // UART_get_data(void)
 138:../src/UART.c **** // returns received data
 139:../src/UART.c **** //***************************************
 140:../src/UART.c **** uint8_t UART_get_data(void)
 141:../src/UART.c **** {
  83               		.loc 1 141 0
  84               		.cfi_startproc
  85               	/* prologue: function */
  86               	/* frame size = 0 */
  87               	/* stack size = 0 */
  88               	.L__stack_usage = 0
 142:../src/UART.c **** 	return (PullQueue());
  89               		.loc 1 142 0
  90 0000 0E94 0000 		call PullQueue
  91               	.LVL3:
 143:../src/UART.c **** }
  92               		.loc 1 143 0
  93 0004 0895      		ret
  94               		.cfi_endproc
  95               	.LFE10:
  97               		.section	.text.UART_ReceivePolling,"ax",@progbits
  98               	.global	UART_ReceivePolling
 100               	UART_ReceivePolling:
 101               	.LFB12:
 144:../src/UART.c **** //***************************************
 145:../src/UART.c **** // UART_send_data(uint8_t)
 146:../src/UART.c **** // Sends one byte to the UART (blocking) 
 147:../src/UART.c **** //***************************************
 148:../src/UART.c **** void UART_send_data(uint8_t data)
 149:../src/UART.c **** {
 150:../src/UART.c **** 	UART_TransmitPolling(data);
 151:../src/UART.c **** }
 152:../src/UART.c **** 
 153:../src/UART.c **** // Private functions
 154:../src/UART.c **** 
 155:../src/UART.c **** uint8_t UART_ReceivePolling()
 156:../src/UART.c **** {
 102               		.loc 1 156 0
 103               		.cfi_startproc
 104               	/* prologue: function */
 105               	/* frame size = 0 */
 106               	/* stack size = 0 */
 107               	.L__stack_usage = 0
 157:../src/UART.c **** 	uint8_t DataByte;
 158:../src/UART.c **** 	while (( UCSR0A & (1<<RXC0)) == 0) {}; // Do nothing until data have been received
 108               		.loc 1 158 0
 109 0000 E0EC      		ldi r30,lo8(-64)
 110 0002 F0E0      		ldi r31,0
 111               	.L5:
 112               		.loc 1 158 0 is_stmt 0 discriminator 1
 113 0004 8081      		ld r24,Z
 114               		.loc 1 158 0 is_stmt 1 discriminator 1
 115 0006 8823      		tst r24
 116 0008 04F4      		brge .L5
 159:../src/UART.c **** 	DataByte = UDR0 ;
 117               		.loc 1 159 0
 118 000a 8091 C600 		lds r24,198
 119               	.LVL4:
 160:../src/UART.c **** 	return DataByte;
 161:../src/UART.c **** }
 120               		.loc 1 161 0
 121 000e 0895      		ret
 122               		.cfi_endproc
 123               	.LFE12:
 125               		.section	.text.UART_TransmitPolling,"ax",@progbits
 126               	.global	UART_TransmitPolling
 128               	UART_TransmitPolling:
 129               	.LFB13:
 162:../src/UART.c **** 
 163:../src/UART.c **** void UART_TransmitPolling(uint8_t DataByte)
 164:../src/UART.c **** {
 130               		.loc 1 164 0
 131               		.cfi_startproc
 132               	.LVL5:
 133               	/* prologue: function */
 134               	/* frame size = 0 */
 135               	/* stack size = 0 */
 136               	.L__stack_usage = 0
 165:../src/UART.c **** 	while (( UCSR0A & (1<<UDRE0)) == 0) {}; // Do nothing until UDR is ready
 137               		.loc 1 165 0
 138 0000 E0EC      		ldi r30,lo8(-64)
 139 0002 F0E0      		ldi r31,0
 140               	.L8:
 141               		.loc 1 165 0 is_stmt 0 discriminator 1
 142 0004 9081      		ld r25,Z
 143               		.loc 1 165 0 is_stmt 1 discriminator 1
 144 0006 95FF      		sbrs r25,5
 145 0008 00C0      		rjmp .L8
 166:../src/UART.c **** 	UDR0 = DataByte;
 146               		.loc 1 166 0
 147 000a 8093 C600 		sts 198,r24
 148 000e 0895      		ret
 149               		.cfi_endproc
 150               	.LFE13:
 152               		.section	.text.UART_send_data,"ax",@progbits
 153               	.global	UART_send_data
 155               	UART_send_data:
 156               	.LFB11:
 149:../src/UART.c **** 	UART_TransmitPolling(data);
 157               		.loc 1 149 0
 158               		.cfi_startproc
 159               	.LVL6:
 160               	/* prologue: function */
 161               	/* frame size = 0 */
 162               	/* stack size = 0 */
 163               	.L__stack_usage = 0
 150:../src/UART.c **** }
 164               		.loc 1 150 0
 165 0000 0E94 0000 		call UART_TransmitPolling
 166               	.LVL7:
 167 0004 0895      		ret
 168               		.cfi_endproc
 169               	.LFE11:
 171               		.section	.text.UART_putstring,"ax",@progbits
 172               	.global	UART_putstring
 174               	UART_putstring:
 175               	.LFB8:
 121:../src/UART.c **** 	while(*StringPtr != 0x00){
 176               		.loc 1 121 0
 177               		.cfi_startproc
 178               	.LVL8:
 179 0000 CF93      		push r28
 180               	.LCFI0:
 181               		.cfi_def_cfa_offset 3
 182               		.cfi_offset 28, -2
 183 0002 DF93      		push r29
 184               	.LCFI1:
 185               		.cfi_def_cfa_offset 4
 186               		.cfi_offset 29, -3
 187               	/* prologue: function */
 188               	/* frame size = 0 */
 189               	/* stack size = 2 */
 190               	.L__stack_usage = 2
 191 0004 EC01      		movw r28,r24
 122:../src/UART.c **** 		UART_send_data(*StringPtr);
 192               		.loc 1 122 0
 193 0006 8881      		ld r24,Y
 194               	.LVL9:
 195 0008 8823      		tst r24
 196 000a 01F0      		breq .L11
 197 000c 2196      		adiw r28,1
 198               	.LVL10:
 199               	.L13:
 200               	.LBB8:
 201               	.LBB9:
 150:../src/UART.c **** }
 202               		.loc 1 150 0
 203 000e 0E94 0000 		call UART_TransmitPolling
 204               	.LVL11:
 205               	.LBE9:
 206               	.LBE8:
 122:../src/UART.c **** 		UART_send_data(*StringPtr);
 207               		.loc 1 122 0
 208 0012 8991      		ld r24,Y+
 209               	.LVL12:
 210 0014 8111      		cpse r24,__zero_reg__
 211 0016 00C0      		rjmp .L13
 212               	.LVL13:
 213               	.L11:
 214               	/* epilogue start */
 125:../src/UART.c **** 
 215               		.loc 1 125 0
 216 0018 DF91      		pop r29
 217 001a CF91      		pop r28
 218 001c 0895      		ret
 219               		.cfi_endproc
 220               	.LFE8:
 222               		.section	.text.uart_test,"ax",@progbits
 223               	.global	uart_test
 225               	uart_test:
 226               	.LFB7:
  76:../src/UART.c **** 
 227               		.loc 1 76 0
 228               		.cfi_startproc
 229               	/* prologue: function */
 230               	/* frame size = 0 */
 231               	/* stack size = 0 */
 232               	.L__stack_usage = 0
 233               	.L16:
 234               	.LBB16:
 235               	.LBB17:
 134:../src/UART.c **** }
 236               		.loc 1 134 0
 237 0000 0E94 0000 		call QueueStatus
 238               	.LVL14:
 239               	.LBE17:
 240               	.LBE16:
  99:../src/UART.c **** 				{
 241               		.loc 1 99 0
 242 0004 8823      		tst r24
 243 0006 01F0      		breq .L16
 244               	.LBB18:
 245               	.LBB19:
 142:../src/UART.c **** }
 246               		.loc 1 142 0
 247 0008 0E94 0000 		call PullQueue
 248               	.LVL15:
 249               	.LBE19:
 250               	.LBE18:
 251               	.LBB20:
 252               	.LBB21:
 150:../src/UART.c **** }
 253               		.loc 1 150 0
 254 000c 8F5F      		subi r24,lo8(-(1))
 255               	.LVL16:
 256 000e 0E94 0000 		call UART_TransmitPolling
 257               	.LVL17:
 258 0012 00C0      		rjmp .L16
 259               	.LBE21:
 260               	.LBE20:
 261               		.cfi_endproc
 262               	.LFE7:
 264               		.section	.text.UART_TransmitInterrupt,"ax",@progbits
 265               	.global	UART_TransmitInterrupt
 267               	UART_TransmitInterrupt:
 268               	.LFB14:
 167:../src/UART.c **** }
 168:../src/UART.c **** 
 169:../src/UART.c **** void UART_TransmitInterrupt(uint8_t Buffer)
 170:../src/UART.c **** {
 269               		.loc 1 170 0
 270               		.cfi_startproc
 271               	.LVL18:
 272               	/* prologue: function */
 273               	/* frame size = 0 */
 274               	/* stack size = 0 */
 275               	.L__stack_usage = 0
 171:../src/UART.c **** 	USART_TransmitBuffer = Buffer;
 276               		.loc 1 171 0
 277 0000 8093 0000 		sts USART_TransmitBuffer,r24
 172:../src/UART.c **** 	UCSR0B |= DATA_REGISTER_EMPTY_INTERRUPT; // Enables the Interrupt
 278               		.loc 1 172 0
 279 0004 E1EC      		ldi r30,lo8(-63)
 280 0006 F0E0      		ldi r31,0
 281 0008 8081      		ld r24,Z
 282               	.LVL19:
 283 000a 8062      		ori r24,lo8(32)
 284 000c 8083      		st Z,r24
 285               	.LVL20:
 286 000e 0895      		ret
 287               		.cfi_endproc
 288               	.LFE14:
 290               		.section	.text.__vector_19,"ax",@progbits
 291               	.global	__vector_19
 293               	__vector_19:
 294               	.LFB15:
 173:../src/UART.c **** }
 174:../src/UART.c **** 
 175:../src/UART.c **** 
 176:../src/UART.c **** // ================================== TX & RX ISR ==================================
 177:../src/UART.c **** 
 178:../src/UART.c **** 
 179:../src/UART.c **** //======= TX ISR =======================
 180:../src/UART.c **** ISR(USART_UDRE_vect)
 181:../src/UART.c **** {
 295               		.loc 1 181 0
 296               		.cfi_startproc
 297 0000 1F92      		push r1
 298               	.LCFI2:
 299               		.cfi_def_cfa_offset 3
 300               		.cfi_offset 1, -2
 301 0002 0F92      		push r0
 302               	.LCFI3:
 303               		.cfi_def_cfa_offset 4
 304               		.cfi_offset 0, -3
 305 0004 0FB6      		in r0,__SREG__
 306 0006 0F92      		push r0
 307 0008 1124      		clr __zero_reg__
 308 000a 8F93      		push r24
 309               	.LCFI4:
 310               		.cfi_def_cfa_offset 5
 311               		.cfi_offset 24, -4
 312 000c EF93      		push r30
 313               	.LCFI5:
 314               		.cfi_def_cfa_offset 6
 315               		.cfi_offset 30, -5
 316 000e FF93      		push r31
 317               	.LCFI6:
 318               		.cfi_def_cfa_offset 7
 319               		.cfi_offset 31, -6
 320               	/* prologue: Signal */
 321               	/* frame size = 0 */
 322               	/* stack size = 6 */
 323               	.L__stack_usage = 6
 182:../src/UART.c **** 	UDR0 = USART_TransmitBuffer;
 324               		.loc 1 182 0
 325 0010 8091 0000 		lds r24,USART_TransmitBuffer
 326 0014 8093 C600 		sts 198,r24
 183:../src/UART.c **** 	UCSR0B &= ~DATA_REGISTER_EMPTY_INTERRUPT; // Disables the Interrupt, uncomment for one time transm
 327               		.loc 1 183 0
 328 0018 E1EC      		ldi r30,lo8(-63)
 329 001a F0E0      		ldi r31,0
 330 001c 8081      		ld r24,Z
 331 001e 8F7D      		andi r24,lo8(-33)
 332 0020 8083      		st Z,r24
 333               	/* epilogue start */
 184:../src/UART.c **** }
 334               		.loc 1 184 0
 335 0022 FF91      		pop r31
 336 0024 EF91      		pop r30
 337 0026 8F91      		pop r24
 338 0028 0F90      		pop r0
 339 002a 0FBE      		out __SREG__,r0
 340 002c 0F90      		pop r0
 341 002e 1F90      		pop r1
 342 0030 1895      		reti
 343               		.cfi_endproc
 344               	.LFE15:
 346               		.section	.text.__vector_18,"ax",@progbits
 347               	.global	__vector_18
 349               	__vector_18:
 350               	.LFB16:
 185:../src/UART.c **** 
 186:../src/UART.c **** //============== RX ISR =======================
 187:../src/UART.c **** ISR(USART_RX_vect)
 188:../src/UART.c **** {
 351               		.loc 1 188 0
 352               		.cfi_startproc
 353 0000 1F92      		push r1
 354               	.LCFI7:
 355               		.cfi_def_cfa_offset 3
 356               		.cfi_offset 1, -2
 357 0002 0F92      		push r0
 358               	.LCFI8:
 359               		.cfi_def_cfa_offset 4
 360               		.cfi_offset 0, -3
 361 0004 0FB6      		in r0,__SREG__
 362 0006 0F92      		push r0
 363 0008 1124      		clr __zero_reg__
 364 000a 2F93      		push r18
 365               	.LCFI9:
 366               		.cfi_def_cfa_offset 5
 367               		.cfi_offset 18, -4
 368 000c 3F93      		push r19
 369               	.LCFI10:
 370               		.cfi_def_cfa_offset 6
 371               		.cfi_offset 19, -5
 372 000e 4F93      		push r20
 373               	.LCFI11:
 374               		.cfi_def_cfa_offset 7
 375               		.cfi_offset 20, -6
 376 0010 5F93      		push r21
 377               	.LCFI12:
 378               		.cfi_def_cfa_offset 8
 379               		.cfi_offset 21, -7
 380 0012 6F93      		push r22
 381               	.LCFI13:
 382               		.cfi_def_cfa_offset 9
 383               		.cfi_offset 22, -8
 384 0014 7F93      		push r23
 385               	.LCFI14:
 386               		.cfi_def_cfa_offset 10
 387               		.cfi_offset 23, -9
 388 0016 8F93      		push r24
 389               	.LCFI15:
 390               		.cfi_def_cfa_offset 11
 391               		.cfi_offset 24, -10
 392 0018 9F93      		push r25
 393               	.LCFI16:
 394               		.cfi_def_cfa_offset 12
 395               		.cfi_offset 25, -11
 396 001a AF93      		push r26
 397               	.LCFI17:
 398               		.cfi_def_cfa_offset 13
 399               		.cfi_offset 26, -12
 400 001c BF93      		push r27
 401               	.LCFI18:
 402               		.cfi_def_cfa_offset 14
 403               		.cfi_offset 27, -13
 404 001e EF93      		push r30
 405               	.LCFI19:
 406               		.cfi_def_cfa_offset 15
 407               		.cfi_offset 30, -14
 408 0020 FF93      		push r31
 409               	.LCFI20:
 410               		.cfi_def_cfa_offset 16
 411               		.cfi_offset 31, -15
 412               	/* prologue: Signal */
 413               	/* frame size = 0 */
 414               	/* stack size = 15 */
 415               	.L__stack_usage = 15
 189:../src/UART.c **** 	PushQueue(UDR0);
 416               		.loc 1 189 0
 417 0022 8091 C600 		lds r24,198
 418 0026 0E94 0000 		call PushQueue
 419               	.LVL21:
 420               	/* epilogue start */
 190:../src/UART.c **** }
 421               		.loc 1 190 0
 422 002a FF91      		pop r31
 423 002c EF91      		pop r30
 424 002e BF91      		pop r27
 425 0030 AF91      		pop r26
 426 0032 9F91      		pop r25
 427 0034 8F91      		pop r24
 428 0036 7F91      		pop r23
 429 0038 6F91      		pop r22
 430 003a 5F91      		pop r21
 431 003c 4F91      		pop r20
 432 003e 3F91      		pop r19
 433 0040 2F91      		pop r18
 434 0042 0F90      		pop r0
 435 0044 0FBE      		out __SREG__,r0
 436 0046 0F90      		pop r0
 437 0048 1F90      		pop r1
 438 004a 1895      		reti
 439               		.cfi_endproc
 440               	.LFE16:
 442               		.comm	USART_ReceiveBuffer,1,1
 443               		.comm	USART_TransmitBuffer,1,1
 444               		.text
 445               	.Letext0:
 446               		.file 3 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\in
 447               		.file 4 "../src/cqueue.h"
DEFINED SYMBOLS
                            *ABS*:00000000 UART.c
              UART.s:2      *ABS*:0000003e __SP_H__
              UART.s:3      *ABS*:0000003d __SP_L__
              UART.s:4      *ABS*:0000003f __SREG__
              UART.s:5      *ABS*:00000000 __tmp_reg__
              UART.s:6      *ABS*:00000001 __zero_reg__
              UART.s:13     .text.UART_Init:00000000 UART_Init
              UART.s:62     .text.UART_rx_status:00000000 UART_rx_status
              UART.s:81     .text.UART_get_data:00000000 UART_get_data
              UART.s:100    .text.UART_ReceivePolling:00000000 UART_ReceivePolling
              UART.s:128    .text.UART_TransmitPolling:00000000 UART_TransmitPolling
              UART.s:155    .text.UART_send_data:00000000 UART_send_data
              UART.s:174    .text.UART_putstring:00000000 UART_putstring
              UART.s:225    .text.uart_test:00000000 uart_test
              UART.s:267    .text.UART_TransmitInterrupt:00000000 UART_TransmitInterrupt
                            *COM*:00000001 USART_TransmitBuffer
              UART.s:293    .text.__vector_19:00000000 __vector_19
              UART.s:349    .text.__vector_18:00000000 __vector_18
                            *COM*:00000001 USART_ReceiveBuffer
                           .group:00000000 wm4.sfr_defs.h.36.473802ecbcb5d4d38de6c7efbfcd3c60
                           .group:00000000 wm4.stdint.h.41.052d062c327f27e210bb72c3d087afe5
                           .group:00000000 wm4.inttypes.h.96.afb9c4be73a069861f8689c997efc518
                           .group:00000000 wm4.sfr_defs.h.128.38ceebe2fb099c106e85a566519e0f1a
                           .group:00000000 wm4.iom328p.h.44.29c929f46483155923fc58520c74ebf7
                           .group:00000000 wm4.portpins.h.34.21289185946cbf62723ecc8db6cdc3ff
                           .group:00000000 wm4.common.h.35.c7e66042b2128622b9d3bddccc9a39f4
                           .group:00000000 wm4.version.h.54.85699b1a50c61c991a37d67b69e79e95
                           .group:00000000 wm4.fuse.h.36.5c373c650020c0efef2cbaa98ea802c3
                           .group:00000000 wm4.lock.h.36.51f311078904691e8f8c3d70111251d8
                           .group:00000000 wm4.delay.h.36.9b049a49ceee302c08fd72aec728bf54
                           .group:00000000 wm4.math.h.49.c8a36eddb532146e0bb8ca9326ea4652
                           .group:00000000 wm4.interrupt.h.36.b2193b640edda749ea0a45a8be5976c8
                           .group:00000000 wm4.cqueue.h.2.ddb4abc33b3476710e33c1abf058974f

UNDEFINED SYMBOLS
QueueInit
QueueStatus
PullQueue
PushQueue
__do_clear_bss
